<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>INFO-F-420 Project</title>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script type="module" src="js/index.js"></script>
        <link rel="stylesheet" href="css/index.css">
    </head>
    <body>   
        <!-- Wrapper for the layout -->
        <div id="content-wrapper">
            <nav id="table-of-contents">
                <h2>Table of Contents</h2>
                <ul>
                    <li><a href="#intro">Introduction</a></li>
                    <li><a href="#core-concepts">Core Concepts</a></li>
                    <li><a href="#symmetries">Symmetries in Tilings</a></li>
                    <li><a href="#algo">Quarter-Turn Factorization Algorithm</a></li>
                    <li><a href="#conclusion">Conclusion</a></li>
                    <li><a href="#appendix">Appendix</a></li>
                </ul>
            </nav>
            
            <main>
                <header>
                
                    <h1>Isohedral Tilings & Folding Tiles</h1>
                    <p>by Sofia Chica Cobo, Alban Linchet Martinez, Zoé Moeremans</p>
                    <div style="text-align: center;">
                        <img src="images/tiling1.png" alt="An example of tiling pattern with rotational symmetry" width="30%">
                    </div>
                </header>
                <section>
                    <h2 id="intro">Introduction</h2>
            <p>
                In the world of geometry, tiling refers to the process of covering a surface with a pattern of shapes, called tiles, without gaps or overlaps.
                One fascinating type of tiling is <strong>isohedral tiling</strong>, where all tiles in the pattern are identical in shape. This project delves into
                the study of isohedral tiles, specifically those exhibiting <strong>rotational symmetries</strong>.
            </p>
            <p>
                Rotational symmetries are properties that allow a shape to be rotated around a central point without changing its overall appearance. The main focus
                of this project is to develop algorithms that can detect isohedral tiles with specific rotational symmetries, namely <strong>3-fold, 4-fold, and
                6-fold</strong> symmetries. These symmetries are particularly interesting as they allow the tiles to be rotated by certain angles and still match
                the original pattern.
            </p>

            <h2 id="core-concepts">Core Concepts</h2>

            <div class="definition">
                <h4>Definition: Tile</h4>
                <p>A <strong>tile</strong> is a shape or geometric figure (like a polyomino) used in the process of tiling a plane or surface. Tiling (or tessellation) involves covering a surface entirely with copies of one or more tiles without any gaps or overlaps.</p>
            </div>
            
            <div class="definition">
                <h4>Definition: Isohedral Tile</h4>
                <p>An <strong>isohedral tile</strong> is a shape that can tile the plane such that every tile in the tiling is identical in shape and size, and each one can be mapped onto any other by a symmetry of the tiling. This property is also referred to as transitivity, meaning the tiling pattern exhibits uniformity, as each tile looks indistinguishable in its position relative to others in the tiling.</p>
            </div>

            <div class="definition">
                <h4>Definition: Polyomino</h4>
                <p>A <strong>polyomino</strong> is a plane geometric figure formed by joining one or more equal squares edge to edge.</p>
            </div>

            <div class="definition">
                <h4>Definition: Symmetry</h4>
                <p><strong>Symmetry</strong> in mathematics refers to a transformation that leaves an object looking the same after it has been applied. For tilings, symmetries include rotations, reflections, and translations that map the tiling onto itself.</p>
                <p><strong>Example of Symmetry:</strong> A square has 4-fold rotational symmetry, meaning it can be rotated by 90 degrees and still look the same.</p>
            </div>


            <div style="text-align: center;">
                <img src="images/tiling2.png" alt="Example of tiling" width="25%">
            </div>

            <div class="definition">
                <h4>Definition: Boundary Word</h4>
                <p>A <strong>boundary word</strong> is a sequence that represents the directions taken when traversing the perimeter of a tile. For this project, we will read the boundary words starting from the top left corner (an arbitrary choice) and proceed in a clockwise direction. The boundary word is composed of the letters representing the four cardinal directions:</p>
                <ul>
                    <li><strong>R</strong> (Right)</li>
                    <li><strong>U</strong> (Up)</li>
                    <li><strong>L</strong> (Left)</li>
                    <li><strong>D</strong> (Down)</li>
                </ul>
                <p><strong>Example:</strong> Consider a simple rectangle tile. Starting from the top left corner and moving clockwise, its boundary word could be represented as "rrrdlllu".</p>
            </div>

            <div style="text-align: center;">
                <img src="images/bword.png" alt="Example of boundary word" width="25%">
            </div>

            <div class="definition">
                <h4>Definition: Period</h4>
                <p>A <strong>period</strong> of a word \( W \) is the smallest positive integer \( p \) such that \( W[i] = W[i + p] \) for all valid \( i \).</p>
                <p><strong>Example:</strong> In the word "ababab", the smallest period is 2, since the pattern "ab" repeats.</p>
            </div>

            <div class="definition">
                <h4>Definition: Palindrome</h4>
                <p>A <strong>palindrome</strong> is a word or sequence that reads the same forward and backward. In the context of boundary words, a palindrome indicates reflective symmetry along an axis.</p>
                <p><strong>Example of a Palindrome:</strong> The word "dduudd" is a palindrome because it reads the same forwards and backwards.</p>
                <p><strong>Formally:</strong> A word \( W \) of length \( n \) is a palindrome if \( W[i] = W[n - i + 1] \) for all \( i \) from \( 1 \) to \( n \).</p>
            </div>

            <div class="definition">
                <h4>Definition: Θ-Drome</h4>
                <p>A <strong>Θ-drome</strong> is a generalization of palindromes for rotational symmetries. It is a word that is symmetric under rotation by an angle \( \theta \) degrees.</p>
                <p>A word \( X \) is a \( \theta \)-drome if it can be written in the form:</p>
                <blockquote>
                    \[
                    X = Y \cdot t_{\theta + 180}(\widetilde{Y})
                    \]
                </blockquote>
                <p><strong>Example of a 90-drome:</strong> Consider the boundary word "rurd", it is a 90-drome because 'urrddr' = \( Y \cdot t_{90+180}({\widetilde{Y}}) \) with \( Y \) = "urr".</p>
            </div>

            <div style="text-align: center;">
                <img src="images/90drome.png" alt="Example of 90 drome" width="50%">
            </div>

            <div class="definition">
                <h4>Definition: Admissibility</h4>
                <p>An <strong>admissible factor</strong> is a substring \( X \) of the boundary word \( W \) that satisfies one of the following conditions, ensuring it can be part of a valid quarter-turn factorization:</p>
                <ul>
                    <li>
                        <strong>Θ-drome:</strong>
                        <ul>
                            <li><em>Definition:</em> A word \( X \) is a Θ-drome if \( X = Y \cdot ( t_{\Theta+180}\{\widetilde{Y}\} \)), where \( {\widetilde{Y}} \) is the end segment of \( Y \), and \( t_{\Theta+180} \) represents a transformation combining a Θ-degree rotation with a 180-degree rotation.</li>
                            <li><em>Admissibility Condition:</em> \( W = XU \) with \( U[-1] \neq t_{\Theta+180}(U)[1] \).</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <div class="definition">
                <h4>Useful notations</h4>
                <ol>
                    <li><strong>\( \overline{W} \)</strong> (Complement of a word \( W \)): The word obtained by replacing each letter in \( W \) with its complement.</li>
                    <li><strong>\( \widetilde{W} \)</strong> (Reverse of a word \( W \)): The letters of \( W \) in reverse order.</li>
                    <li><strong>\( \overline{\widetilde{W}} \)</strong> (Backtrack of a word \( W \)): The complement of the reverse word \( W \).</li>
                </ol>
            </div>

        </section>
        <section>
            <h2 id="symmetries">Symmetries in Tilings</h2>
        
            <p>Here, we focus on identifying isohedral tiles characterized by 3-fold, 4-fold, and 6-fold rotational symmetries. The specific polygons considered are:</p>
            <ul>
                <li><strong>Polyiamonds:</strong> Built from equilateral triangles, exhibiting 3-fold rotational symmetry.</li>
                <li><strong>Polyominoes:</strong> Composed of squares, displaying 4-fold rotational symmetry.</li>
                <li><strong>Polyhexes:</strong> Made from regular hexagons, allowing for 3-fold and 6-fold rotational symmetries.</li>
            </ul>
        
            <h3 >Using the Quarter-Turn Factorization Algorithm for Rotational Symmetries</h3>
            <p>The <strong>quarter-turn factorization algorithm</strong>, described below, is not limited to detecting 4-fold rotational symmetry. By adjusting the parameter \( \Theta \) (the rotation angle), the same algorithm can be applied to identify other rotational symmetries in boundary words. The algorithm works as follows:</p>
            <ul>
                <li><strong>For 3-fold rotational symmetry:</strong> Set \( \Theta = 120° \).</li>
                <li><strong>For 4-fold rotational symmetry:</strong> Set \( \Theta = 90° \) (default case in the algorithm).</li>
                <li><strong>For 6-fold rotational symmetry:</strong> Set \( \Theta = 60° \).</li>
            </ul>
            <p>The logic of the algorithm remains consistent across these symmetries. It identifies admissible factors such as palindromes and \( \Theta \)-dromes, preprocesses them, and verifies potential tiling configurations.</p>
        
            <h3>Quarter-Turn Factorization in Boundary Words</h3>
            <p>In the study of polyominoes and their tiling properties, understanding the symmetries of their boundary words is crucial. This section provides a comprehensive explanation of an algorithm for detecting quarter-turn factorizations in boundary words of polyominoes. We will define key concepts, present important lemmas with proofs, and explain the algorithm in a didactic manner, ensuring clarity and accessibility.</p>
        
            <div class="definition">
                <h4>Definition: Quarter-Turn Factorization</h4>
                <p>A <strong>quarter-turn factorization</strong> of a boundary word \( W \) is a factorization of the form <strong>\( W = ABC \)</strong>, where:</p>
                <ul>
                    <li><strong>A</strong> is a palindrome.</li>
                    <li><strong>B</strong> and <strong>C</strong> are 90-dromes.</li>
                </ul>
                <p>This factorization helps identify 4-fold rotational symmetries in polyominoes.</p>
            </div>
        
            <h4>Example of Quarter-Turn Factorization</h4>
            <p>Consider the boundary word <strong>W = "uurruudurdrlrlud"</strong>.</p>
            <ul>
                <li><strong>A = "uurruu"</strong> &mdash; This is a palindrome because it reads the same forwards and backwards.</li>
                <li><strong>B = "durdrl"</strong> &mdash; This is a 90-drome. Applying the rotation for a 90-drome:
                    <ul>
                        <li>\( t_{90+180}(u) = r \)</li>
                        <li>\( t_{90+180}(d) = l \)</li>
                        <li>\( t_{90+180}(l) = u \)</li>
                        <li>\( t_{90+180}(r) = d \)</li>
                    </ul>
                    We get for the first part of B "durl" : "lrd" which we reverse to get the 90-drome: <strong>"drl"</strong>.
                </li>
                <li><strong>C = "rlud"</strong> &mdash; Similarly, <strong>C</strong> is a 90-drome by the same reasoning as <strong>B</strong>.</li>
            </ul>
            <p>Therefore, <strong>W = A + B + C = "uurruu" + "durdrl" + "rlud"</strong> is a valid quarter-turn factorization.</p>
        
            <p>Here is an illustration example below using the word.</p>
            <div style="text-align: center;">
                <img src="images/quarterTurn.png" alt="Illustration of Quarter-Turn Factorization">
            </div>
        
            <h3>Lemmas and Proofs</h3>
        
            <p>To understand and develop the algorithm for detecting quarter-turn factorizations, we rely on several important lemmas. These lemmas help establish the properties of palindromes and 90-dromes within boundary words.</p>
        
            <div class="lemma">
                <h4>Lemma 4.12 (Theorem 9.1.1 of [1])</h4>
                <p>Two circular words \( X \) and \( Y \) can be preprocessed in \( O(|X| + |Y|) \) time to support the following queries in \( O(1) \) time: What is the longest common factor of \( X \) and \( Y \) starting at \( X[i] \) and \( Y[j] \)?</p>
                <p><strong>Explanation:</strong> This lemma provides an efficient method to preprocess two circular words, enabling constant-time queries to determine the longest common substring starting at specified positions within each word. This capability is crucial for optimizing algorithms that require frequent and rapid comparisons of word segments, such as those involved in pattern matching or factorization processes.</p>
            </div>
        
            <!-- Lemma 1 -->
            <div class="lemma">
                <h4>Lemma 5.1</h4>
                <p>Let \( W \) be a word with a period \( p \), and \( X \) a 90-drome subword of \( W \). Then we have \( |X| \leq p \).</p>
                <p><strong>Explanation:</strong> In a word that repeats every \( p \) characters, any 90-drome within it cannot be longer than \( p \). This is because the symmetry imposed by the 90-drome cannot extend beyond the repeating pattern of the word.</p>
            </div>
        
            <!-- Lemma 2 -->
            <div class="lemma">
                <h4>Lemma 5.2</h4>
                <p>Let \( W \) be a word. Let \( P \) be a prefix and \( S \) be a suffix of \( W \), both being distinct 90-dromes with \( |P|, |S| \geq \frac{2}{3}|W| \). Then any other 90-drome factor of \( W \) not sharing the center with \( P \) or \( S \) has length less than \( 2|W| - (|P| + |S|) \).</p>
                <p><strong>Explanation:</strong> This lemma limits the length of any additional 90-drome in \( W \) that doesn't overlap with the centers of \( P \) or \( S \). Essentially, large 90-dromes consume much of the word's length, restricting the size of other non-overlapping 90-dromes.</p>
            </div>
        
            <!-- Lemma 3 -->
            <div class="lemma">
                <h4>Lemma 5.3</h4>
                <p>Let \( W \) be a word. Let \( P \) and \( Q \) be prefixes of \( W \), both being 90-dromes, with \( |P| < |Q| < |W| \). Then \( |P| < \frac{2}{3}|W| \).</p>
                <p><strong>Explanation:</strong> If there are two 90-drome prefixes with different lengths, the shorter one cannot be too long. This is due to the limitations imposed by the presence of the longer 90-drome on the structure of the word.</p>
            </div>
        
            <!-- Lemma 4 -->
            <div class="lemma">
                <h4>Lemma 5.4</h4>
                <p>Let \( W \) be a boundary word. There exist \( O(1) \) admissible 90-drome factors of \( W \) with length at least \( \frac{|W|}{3} \).</p>
                <p><strong>Explanation:</strong> This lemma states that only a constant number of long 90-dromes can exist in \( W \). This is important for the efficiency of our algorithm, as it limits the number of candidates we need to consider.</p>
            </div>
        
            <!-- Lemma 5 -->
            <div class="lemma">
                <h4>Lemma 5.5</h4>
                <p>Let \( W \) be a word. Let \( P \) be a prefix and \( S \) be a suffix of \( W \), both being palindromes with \( |P|, |S| \geq \frac{2}{3}|W| \), and \( P \neq S \). Then \( W \) has a period of length \( 2|W| - (|P| + |S|) \).</p>
                <p><strong>Explanation:</strong> The overlapping structure of long palindromic prefixes and suffixes imposes a periodic pattern on the word \( W \).</p>
            </div>
        
            <!-- Lemma 6 -->
            <div class="lemma">
                <h4>Lemma 5.6</h4>
                <p>Under the same conditions as Lemma 5, any admissible middle palindrome of \( W \) has length at most \( 2|W| - (|P| + |S|) \).</p>
                <p><strong>Explanation:</strong> Middle palindromes not overlapping with the long palindromic prefix or suffix must be short due to the periodicity imposed by the longer palindromes.</p>
            </div>
        
            <!-- Lemma 7 -->
            <div class="lemma">
                <h4>Lemma 5.7</h4>
                <p>Let \( W \) be a word. There exists an \( O(1) \)-sized set \( F \) of factors of \( W \) such that every admissible palindrome factor with length at least \( \frac{|W|}{3} \) is an affix (prefix or suffix) of an element of \( F \). \( F \) is computable in \( O(|W|) \) time.</p>
                <p><strong>Explanation:</strong> All long palindromic factors are associated with a small, computable set. This allows us to efficiently identify and consider all significant palindromic factors.</p>
            </div>
        
            <!-- Lemma 8 -->
            <div class="lemma">
                <h4>Lemma 5.8</h4>
                <p>In a boundary word \( W = ABC \) with \( A \) a palindrome and \( B \), \( C \) being 90-dromes, \( A \), \( B \), and \( C \) are admissible.</p>
                <p><strong>Explanation:</strong> This lemma confirms that the factors in the quarter-turn factorization meet the necessary conditions to be considered palindromes and 90-dromes within the boundary word.</p>
            </div>
        </section>
        <section>
            <h2 id="algo">Quarter-Turn Factorization Algorithm</h2>
            <p>This document outlines a step-by-step algorithm to determine whether a given boundary word \( W \) of a polyomino \( P \) can be factored into a <strong>quarter-turn factorization</strong>[1] of the form:</p>
            <blockquote>
                <p>\( W = A \cdot D_1 \cdot D_2 \)</p>
                <ul>
                    <li><strong>A</strong> is a <em>palindrome</em>.</li>
                    <li><strong>D₁</strong> and <strong>D₂</strong> are <em>90-dromes</em> (substrings exhibiting symmetry under a 90-degree rotation).</li>
                </ul>
            </blockquote>
        
            <p>The algorithm leverages several lemmas to preprocess \( W \), identify admissible factors, and verify potential factorizations efficiently within \( O(n) \) time complexity, where \( n = |W| \).</p>
        
            <div class="step">
                <h3>Step 1: Preprocessing Admissible Factors</h3>
                <p><strong>Objective:</strong> Identify all admissible <em>palindromic</em> and <em>90-drome</em> factors within the boundary word \( W \) efficiently.</p>
        
                <div class="lemma">
                    <h4>Lemma 4.12</h4>
                    <p><em>Two circular words \( X \) and \( Y \) can be preprocessed in \( O(|X| + |Y|) \) time to support the following queries in \( O(1) \)-time: What is the longest common factor of \( X \) and \( Y \) starting at \( X[i] \) and \( Y[j] \)?</em></p>
                </div>
        
                <p><strong>Explanation:</strong> This lemma allows us to preprocess two circular words so that we can quickly determine the longest common substring (factor) starting at any given positions in both words. This is crucial for efficiently identifying maximal palindromic and 90-drome factors.</p>
        
                <pre><code>
        function preprocessAdmissibleFactors(W):
            // Step 1a: Preprocess Palindromic Factors
            palindromes = preprocessPalindromes(W) // O(n) time
        
            // Step 1b: Preprocess 90-Drome Factors
            dromes = preprocess90Dromes(W) // O(n) time
        
            // Step 1c: Organize Factors into Sorted Lists
            organized = organizeFactors(W, palindromes, dromes) // O(n) time
        
            return organized
                </code></pre>
        
                <p><strong>Function Descriptions: </strong>
                    <ul>
                        <li><code>preprocessPalindromes(W)</code>: Utilizes Lemma 4.12 to preprocess \( W \) and its reflection \( \widetilde{W} \) to enable \( O(1) \)-time queries for the longest palindromic substrings centered at any position.</li>
                        <li><code>preprocess90Dromes(W)</code>: Applies Lemma 4.12 to preprocess \( W \) and its 90-degree rotated version \( t_{90}(\widetilde{W}) \) to facilitate \( O(1) \)-time queries for the longest 90-drome substrings starting at any position.</li>
                        <li><code>organizeFactors(W, palindromes, dromes)</code>: Organizes the identified palindromic and 90-drome factors into length-sorted lists based on their starting and ending positions.</li>
                    </ul>
                </p>
        
                <p><strong>Complexity: </strong>Each sub-step operates in linear time \( O(n) \), ensuring that the overall preprocessing step remains efficient.</p>
            </div>
        
            <div class="step">
                <h3>Step 2: Extracting Long Factors Using the Pigeonhole Principle</h3>
                <p><strong>Objective:</strong> Utilize the pigeonhole principle to identify that any valid quarter-turn factorization must contain at least one <em>long factor</em> (length ≥ \( \frac{n}{3} \)).</p>
        
                <div class="lemma">
                    <h4>Lemma 5.4</h4>
                    <p><em>There are \( O(1) \) admissible long 90-drome factors (length ≥ \( \frac{|W|}{3} \)).</em></p>
                </div>
        
                <pre><code>
        function extractLongFactors(organized, W):
            // Step 2a: Extract Long 90-Drome Factors (Lemma 5.4)
            longDromes = extractLong90Dromes(organized.dromes) // O(1) time
        
            // Step 2b: Summarize Long Palindromic Factors (Lemma 5.3)
            summarizedLetters = summarizeLongPalindromes(organized.palindromes) // O(n) time
        
            return { longDromes, summarizedLetters }
                </code></pre>
        
                <p><strong>Function Descriptions: </strong>
                    <ul>
                        <li><code>extractLong90Dromes(dromes)</code>: Extracts the \( O(1) \) long 90-drome factors based on Lemma 5.4.</li>
                        <li><code>summarizeLongPalindromes(palindromes)</code>: Summarizes long palindromic factors into a compact set of letters as per Lemma 5.3.</li>
                    </ul>
                </p>
        
                <p><strong>Complexity: </strong>The extraction of long 90-drome factors operates in constant time \( O(1) \), while summarizing long palindromic factors operates in linear time \( O(n) \).</p>
            </div>
        
            <div class="step">
                <h3>Step 3: Combining Long 90-Drome Factors with Adjacent 90-Dromes</h3>
                <p><strong>Objective:</strong> Form candidate factorizations by combining each long 90-drome factor with adjacent admissible 90-dromes, then verify if the remaining segment \( A \) is a palindrome. We will use Lemma 5.8 stating that \( ABC \) are admissible if they are respectively, a palindrome and two 90-dromes of our boundary word.</p>
        
                <div class="lemma">
                    <h4>Lemma 5.8</h4>
                    <p><em>If \( P \) is a polyomino with \( B(P) = ABC \), where \( A \) is a palindrome and \( B, C \) are 90-dromes, then \( A, B, C \) are admissible.</em></p>
                </div>
        
                <pre><code>
        function combineLong90Dromes(W, organized, longDromes):
            validFactorizations = []
            n = W.length
        
            for each d in longDromes: // O(1) iterations
                i = d.start
                j = d.end
        
                // Step 3a: Combine with 90-dromes ending at i-1
                prevPos = (i - 1 + n) % n
                endingDromes = getEndingDromes(organized.end90Dromes, prevPos) // O(log n) factors
                for each D₁ in endingDromes: // O(log n)
                    A = extractA(W, D₁, d) // O(1) time
                    if isPalindrome(A): // O(1) time
                        validFactorizations.push({ A: A, D₁: D₁.substring, D₂: d.substring })
        
                // Step 3b: Combine with 90-dromes starting at j+1
                nextPos = (j + 1) % n
                startingDromes = getStartingDromes(organized.start90Dromes, nextPos) // O(log n) factors
                for each D₂ in startingDromes: // O(log n)
                    A = extractA(W, d, D₂) // O(1) time
                    if isPalindrome(A): // O(1) time
                        validFactorizations.push({ A: A, D₁: d.substring, D₂: D₂.substring })
        
                // Step 3c: Handle cases where D₂ is empty
                A_emptyD₂ = W.substring(0, i) // A before D₁
                if isPalindrome(A_emptyD₂): // O(1) time
                    validFactorizations.push({ A: A_emptyD₂, D₁: d.substring, D₂: "" })
        
                // Step 3d: Handle cases where D₁ is empty
                A_emptyD₁ = W.substring(0, j + 1) // A before D₂
                if isPalindrome(A_emptyD₁): // O(1) time
                    validFactorizations.push({ A: A_emptyD₁, D₁: "", D₂: d.substring })
        
            return validFactorizations // Total O(log^2 n) time
                </code></pre>
        
                <p><strong>Function Descriptions: </strong>
                    <ul>
                        <li><code>getEndingDromes(organized.end90Dromes, prevPos)</code>: Retrieves admissible 90-dromes ending at the specified position \( prevPos \) in the boundary word \( W \).</li>
                        <li><code>getStartingDromes(organized.start90Dromes, nextPos)</code>: Retrieves admissible 90-dromes starting at the specified position \( nextPos \) in the boundary word \( W \).</li>
                        <li><code>extractA(W, D₁, D₂)</code>: Extracts the potential palindromic factor \( A \) from the boundary word \( W \) based on the positions of \( D₁ \) and \( D₂ \).</li>
                        <li><code>isPalindrome(A)</code>: Verifies if the extracted substring \( A \) is a palindrome.</li>
                    </ul>
                </p>
        
                <p><strong>Complexity: </strong>Each iteration over the long 90-drome factors is \( O(1) \), and the handling of adjacent factors involves logarithmic time for accessing the stored admissible 90-dromes, yielding an overall complexity of \( O(\log^2 n) \).</p>
            </div>

            <section>
                <h3 id="conclusion">Conclusion</h3>
                <p>The algorithm efficiently determines whether a boundary word \( W \) of a polyomino \( P \) possesses a valid quarter-turn factorization by systematically preprocessing admissible factors, leveraging the pigeonhole principle, and combining factors based on established lemmas. The use of Lemma 4.12 for preprocessing ensures rapid identification of maximal factors, while Lemmas 5.3, 5.4, and 5.8 guide the combination and verification processes, maintaining overall linear time complexity.</p>
    
                <p><strong>Final Note:</strong> While the pseudocode provided offers a clear structural representation, actual implementation may require further optimizations and handling of specific edge cases based on the exact definitions and properties of the polyomino tilings in question.</p>
            </section>
            <section id="polygon_builder">
                    <h2>Process Polygon</h2>
                    <label for="polygon_input">Enter polygon:</label>
                    <input type="text" id="polygon_input" placeholder="rrdllu"/>
                    <button id="process_polygon">Process polygon</button>
                    <div id="output"></div>
                </section>

            </section>

        <section>
            <h2 id="appendix"> Appendix </h2>
            <h3>Supporting Functions and Detailed Explanations</h3>

            <div class="proof">
                <h5>Function: isPalindrome(str)</h5>
                <p><strong>Purpose:</strong> Check if a given string is a palindrome.</p>
                
                <pre><code>
            function isPalindrome(str):
                left = 0
                right = str.length - 1
                while left < right:
                    if str[left] != str[right]:
                        return false
                    left += 1
                    right -= 1
                return true
                </code></pre>

                <p><strong>Explanation:</strong> This function compares characters from both ends of the string moving towards the center. If all corresponding characters match, the string is a palindrome.</p>

                <p><strong>Complexity: </strong>Linear time \( O(m) \), where \( m \) is the length of the string being checked.</p>
            </div>

            <div class="proof">
                <h5>Function: is90Drome(word)</h5>
                <p><strong>Purpose:</strong> Check if a given word is a 90-drome.</p>
                
                <pre><code>
            function is90Drome(word):
                n = word.length
                for i from 0 to n - 1:
                    if word[i] != t90(word[n - i - 1]):
                        return false
                return true
                </code></pre>

                <p><strong>Explanation:</strong> A 90-drome requires that each character at position \( i \) is the 90-degree rotation of the character at position \( n - i - 1 \). This function verifies this condition for all positions.</p>

                <p><strong>Complexity: </strong>Linear time \( O(n) \), where \( n \) is the length of the word.</p>
            </div>

            <div class="proof">
                <h5>Function: getDoubleStartingDromes(start90Dromes, position)</h5>
                <p><strong>Purpose:</strong> Retrieve all pairs \( D₁D₂ \) where \( D₁ \) starts at the given position and \( D₂ \) follows \( D₁ \), including cases where \( D₂ \) is empty.</p>
                
                <pre><code>
            function getDoubleStartingDromes(start90Dromes, position):
                doubleDromes = []
                D₁List = getStartingDromes(start90Dromes, position) // O(log n)
                for each D₁ in D₁List: // O(log n)
                    for each D₂ in getStartingDromes(start90Dromes, D₁.end + 1): // O(log n)
                        doubleDromes.push({ D₁: D₁.substring, D₂: D₂.substring })
                return doubleDromes // O(log^2 n) factors
                </code></pre>

                <p><strong>Function Descriptions: </strong>
                    <ul>
                        <li><code>getStartingDromes(start90Dromes, position)</code>: Retrieves all admissible 90-drome factors starting at a given position.</li>
                    </ul>
                </p>

                <p><strong>Complexity: </strong>Each call retrieves \( O(\log n) \) factors, resulting in \( O(\log^2 n) \) total factors per position.</p>
            </div>

            <div class="proof">
                <h5>Function: getDoubleEndingDromes(end90Dromes, position)</h5>
                <p><strong>Purpose:</strong> Retrieve all pairs \( D₁D₂ \) where \( D₂ \) ends at the given position and \( D₁ \) precedes \( D₂ \), including cases where \( D₁ \) is empty.</p>

                <pre><code>
            function getDoubleEndingDromes(end90Dromes, position):
                doubleDromes = []
                D₂List = getEndingDromes(end90Dromes, position) // O(log n)
                for each D₂ in D₂List: // O(log n)
                    for each D₁ in getEndingDromes(end90Dromes, D₂.start - 1): // O(log n)
                        doubleDromes.push({ D₁: D₁.substring, D₂: D₂.substring })
                return doubleDromes // O(log^2 n) factors
                </code></pre>

                <p><strong>Function Descriptions: </strong>
                    <ul>
                        <li><code>getEndingDromes(end90Dromes, position)</code>: Retrieves all admissible 90-drome factors ending at a given position.</li>
                    </ul>
                </p>

                <p><strong>Complexity: </strong>Each call retrieves \( O(\log n) \) factors, resulting in \( O(\log^2 n) \) total factors per position.</p>
            </div>

            <div class="proof">
                <h5>Function: extractA(W, D₁, D₂)</h5>
                <p><strong>Purpose:</strong> Extract the substring \( A \) based on the positions of \( D₁ \) and \( D₂ \).</p>

                <pre><code>
            function extractA(W, D₁, D₂):
                startA = 0
                endA = D₁.start - 1
                if (endA < 0):
                    endA += W.length
                A = W.substring(startA, endA + 1)
                return A
                </code></pre>

                <p><strong>Explanation: </strong>This function calculates the substring \( A \) that precedes the 90-drome factors \( D₁ \) and \( D₂ \), ensuring proper extraction based on their positions.</p>

                <p><strong>Complexity: </strong>Constant time \( O(1) \), as it involves simple substring extraction.</p>
            </div>

            <div class="proof">
                <h5>Function: getEndingDromes(end90Dromes, position)</h5>
                <p><strong>Purpose:</strong> Retrieve all admissible 90-drome factors ending at a specified position.</p>

                <pre><code>
            function getEndingDromes(end90Dromes, position):
                n = end90Dromes.length
                position = (position + n) % n // Handle circularity
                return end90Dromes[position] || []
                </code></pre>

                <p><strong>Explanation: </strong>This function ensures that the position wraps around correctly in the case of circular words and retrieves the list of 90-drome factors ending at that position.</p>

                <p><strong>Complexity: </strong>Constant time \( O(1) \) for retrieval.</p>
            </div>

            <div class="proof">
                <h5>Function: getStartingDromes(start90Dromes, position)</h5>
                <p><strong>Purpose:</strong> Retrieve all admissible 90-drome factors starting at a specified position.</p>

                <pre><code>
            function getStartingDromes(start90Dromes, position):
                n = start90Dromes.length
                position = (position + n) % n // Handle circularity
                return start90Dromes[position] || []
                </code></pre>

                <p><strong>Explanation: </strong>Similar to <code>getEndingDromes</code>, this function retrieves 90-drome factors starting at a specified position, handling circularity appropriately.</p>

                <p><strong>Complexity: </strong>Constant time \( O(1) \) for retrieval.</p>
            </div>
        </section>

        <section id="references">
            <h2>References</h2>
            <ol>
                <li>
                    Gusfield, D. (1997). <em>Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology</em>. Cambridge University Press.
                </li>
                <li>
                    Petrov, B. (2020). <em>Info F420 Tilings</em>. Retrieved from <a href="https://bpetrov2020.github.io/info_f420_tilings/" target="_blank">https://bpetrov2020.github.io/info_f420_tilings/</a>
                </li>
            </ol>
        </section>
    </main>
</body>
</html>
